package de.bybackfish.sql.core;

import de.bybackfish.sql.annotation.AutoGenerated;
import de.bybackfish.sql.annotation.ForeignKey;
import de.bybackfish.sql.annotation.PrimaryKey;
import de.bybackfish.sql.query.*;
import de.bybackfish.sql.util.ReflectionUtils;

import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.stream.Collectors;

import static de.bybackfish.sql.util.ReflectionUtils.getFieldName;
import static de.bybackfish.sql.util.ReflectionUtils.getTableName;

public class DatabaseModel {
    public static <T extends DatabaseModel> List<T> findMany(Class<T> clazz, SelectQueryBuilder queryBuilder) throws FishSQLException {
        FishDatabase fishDatabase = DatabaseProvider.getDatabase();

        return fishDatabase.select(queryBuilder, clazz);
    }

    public static <T extends DatabaseModel> Optional<T> findOne(Class<T> clazz, SelectQueryBuilder queryBuilder) throws FishSQLException{
        queryBuilder.limit(1);
        List<T> models = findMany(clazz, queryBuilder);
        if (models.isEmpty()) {
            return Optional.empty();
        }
        return Optional.of(models.getFirst());
    }

    public static <T extends DatabaseModel> List<T> all(Class<T> clazz) throws FishSQLException {
        return findMany(clazz, QueryBuilder.select("*"));
    }

    public <T extends DatabaseModel> List<T> linkMany(Class<T> clazz) throws FishSQLException {
        return linkMany(clazz, QueryBuilder.select("*"));
    }

    public <T extends DatabaseModel> List<T> linkMany(Class<T> clazz, SelectQueryBuilder queryBuilder) throws FishSQLException {
        return linkMany(clazz, getTableName(clazz), queryBuilder);
    }

    public <T extends DatabaseModel> List<T> linkMany(Class<T> clazz, String fieldName, SelectQueryBuilder queryBuilder) throws FishSQLException {
        FishDatabase fishDatabase = DatabaseProvider.getDatabase();

        String targetName = getTableName(clazz);

        Map<Field, ForeignKey> foreignKeyFieldNames = getForeignKeyFieldNames(clazz);
        if (foreignKeyFieldNames.isEmpty()) {
            throw new RuntimeException(STR."No foreign key found for \{clazz.getSimpleName()}");
        }
        Map.Entry<Field, ForeignKey> target = foreignKeyFieldNames.entrySet().stream().filter(entry -> entry.getValue().targetColumn().equals(fieldName)).findFirst().orElseThrow(() -> new RuntimeException(STR."No foreign key found for \{clazz.getSimpleName()}"));

        String targetColumn = target.getValue().targetColumn();
        Object value;
        try {
            value = target.getKey().get(this);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }

        queryBuilder.from(targetName);
        queryBuilder.where(where -> where.and(STR."\{targetColumn} = ?",
                value));

        return fishDatabase.executeQuery(queryBuilder, clazz);
    }

    public Map<Field, ForeignKey> getForeignKeyFieldNames(Class<?> clazz) {
        String targetName = getTableName(clazz);
        return ReflectionUtils.getAnnotatedFields(this.getClass(), ForeignKey.class).entrySet()
                .stream().filter(entry -> entry.getValue().targetTable().equals(targetName))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public <T extends DatabaseModel> T linkOne(Class<T> clazz) throws FishSQLException {
        SelectQueryBuilder queryBuilder = QueryBuilder.select("*");
        queryBuilder.limit(1);
        return linkMany(clazz, queryBuilder).getFirst();
    }

    public void insert() throws FishSQLException {
        DatabaseProvider.getDatabase().executeUpdate(insertQueryBuilder());
    }

    public void insertAndUpdateModel() throws FishSQLException {
        InsertQueryBuilder queryBuilder = insertQueryBuilder();

        // All AutoGenerated fields
        Map<String, Field> fieldsToReturn = new HashMap<>();

        for (java.lang.reflect.Field field : ReflectionUtils.getAnnotatedFields(this.getClass(), AutoGenerated.class).keySet()) {
            fieldsToReturn.put(getFieldName(field), field);
        }

        queryBuilder.returning(String.join(", ", fieldsToReturn.keySet()));

        ResultSet execute = queryBuilder.build(DatabaseProvider.getDatabase()).execute();
        try {
            while (execute.next()) {
                for (java.lang.reflect.Field field : fieldsToReturn.keySet().stream().map(fieldsToReturn::get).collect(Collectors.toList())) {
                    field.set(this, execute.getObject(field.getName()));
                }
            }
        } catch (SQLException | IllegalAccessException e) {
            throw new FishSQLException("Failed to Update Model after Inserting: ", e);
        }
    }

    public <T extends DatabaseModel> T insertAndReturnModel(Class<T> clazz) throws FishSQLException {
        InsertQueryBuilder queryBuilder = insertQueryBuilder();
        queryBuilder.returning("*");
        return queryBuilder.build(DatabaseProvider.getDatabase()).unwrap(clazz).getFirst();
    }

    public InsertQueryBuilder insertQueryBuilder() throws FishSQLException {
        InsertQueryBuilder insertQueryBuilder = new InsertQueryBuilder(getTableName(this.getClass()));

        try {
            for (java.lang.reflect.Field field : this.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                String fieldName = getFieldName(field);
                Object value = field.get(this);
                if (value instanceof Optional<?>) {
                    value = ((Optional<?>) value).orElse(null);
                }

                if(ReflectionUtils.getAnnotationFromField(field, AutoGenerated.class) != null
                        && (value == null || Integer.parseInt(value.toString()) == 0 || !Boolean.parseBoolean(value.toString()))
                ) {
                    continue;
                }

                if (value == null) {
                    continue;
                }
                insertQueryBuilder.add(fieldName, value);
            }
        } catch (IllegalAccessException e) {
            throw new FishSQLException(e);
        }

        return insertQueryBuilder;
    }

    public void delete() throws FishSQLException {
        FishDatabase fishDatabase = DatabaseProvider.getDatabase();

        String tableName = getTableName(this.getClass());

        DeleteQueryBuilder deleteQueryBuilder = new DeleteQueryBuilder(tableName);

        WhereQueryBuilder whereQueryBuilder = getDistinctWhereClause();
        deleteQueryBuilder.where(whereQueryBuilder);

        fishDatabase.executeUpdate(deleteQueryBuilder);
    }

    public void update() throws FishSQLException {
        FishDatabase fishDatabase = DatabaseProvider.getDatabase();

        String tableName = getTableName(this.getClass());

        UpdateQueryBuilder updateQueryBuilder = new UpdateQueryBuilder(
                tableName
        );

        for (java.lang.reflect.Field field : this.getClass().getDeclaredFields()) {
            field.setAccessible(true);
            String fieldName = getFieldName(field);
            Object value;
            try {
                value = field.get(this);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
            if (value instanceof Optional<?>) {
                value = ((Optional<?>) value).orElse(null);
            }
            if (value == null) {
                continue;
            }
            updateQueryBuilder.set(fieldName, value);
        }

        WhereQueryBuilder whereQueryBuilder = getDistinctWhereClause();

        if (whereQueryBuilder != null) {
            updateQueryBuilder.where(whereQueryBuilder);
        }

        fishDatabase.executeUpdate(updateQueryBuilder);
    }

    protected Collection<java.lang.reflect.Field> getPrimaryKeyFields() {
        return ReflectionUtils.getAnnotatedFields(this.getClass(), PrimaryKey.class).keySet();
    }

    protected WhereQueryBuilder getDistinctWhereClause() {
        Collection<java.lang.reflect.Field> primaryKeyFields = getPrimaryKeyFields();

        WhereQueryBuilder whereQueryBuilder = new WhereQueryBuilder();

        if (primaryKeyFields.isEmpty()) {
            for (java.lang.reflect.Field field : getClass().getDeclaredFields()) {
                field.setAccessible(true);

                String name = getFieldName(field);
                Object value = null;
                try {
                    value = field.get(this);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }

                if (value == null) {
                    continue;
                }
                whereQueryBuilder.and(STR."\{getTableName(this.getClass())}.\{name} = ?", value);
            }
        } else {
            for (java.lang.reflect.Field field : primaryKeyFields) {
                try {
                    whereQueryBuilder.and(STR."\{getTableName(this.getClass())}.\{getFieldName(field)} = ?", field.get(this));
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        return whereQueryBuilder;
    }

    @Override
    public String toString() {
        Map<String, Object> fields = new HashMap<>();
        for (java.lang.reflect.Field field : this.getClass().getDeclaredFields()) {
            field.setAccessible(true);
            String fieldName = getFieldName(field);
            Object value;
            try {
                value = field.get(this);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
            if (value instanceof Optional<?>) {
                value = ((Optional<?>) value).orElse(null);
            }
            if (value == null) {
                continue;
            }
            fields.put(fieldName, value);
        }
        return """
                %s{%s}
                """.formatted(getTableName(this.getClass()), fields.entrySet().stream().map(entry -> String.format("%s=%s", entry.getKey(), entry.getValue())).collect(Collectors.joining(", ")));
    }
}
